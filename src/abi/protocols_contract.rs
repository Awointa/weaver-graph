// ****
// Auto-generated by cainome do not edit.
// ****

#[derive(Debug)]
pub struct protocols<A: starknet::accounts::ConnectedAccount + Sync> {
    pub address: starknet::core::types::Felt,
    pub account: A,
    pub block_id: starknet::core::types::BlockId,
}
impl<A: starknet::accounts::ConnectedAccount + Sync> protocols<A> {
    pub fn new(address: starknet::core::types::Felt, account: A) -> Self {
        Self {
            address,
            account,
            block_id: starknet::core::types::BlockId::Tag(
                starknet::core::types::BlockTag::Pending,
            ),
        }
    }
    pub fn set_contract_address(&mut self, address: starknet::core::types::Felt) {
        self.address = address;
    }
    pub fn provider(&self) -> &A::Provider {
        self.account.provider()
    }
    pub fn set_block(&mut self, block_id: starknet::core::types::BlockId) {
        self.block_id = block_id;
    }
    pub fn with_block(self, block_id: starknet::core::types::BlockId) -> Self {
        Self { block_id, ..self }
    }
}
#[derive(Debug)]
pub struct protocolsReader<P: starknet::providers::Provider + Sync> {
    pub address: starknet::core::types::Felt,
    pub provider: P,
    pub block_id: starknet::core::types::BlockId,
}
impl<P: starknet::providers::Provider + Sync> protocolsReader<P> {
    pub fn new(address: starknet::core::types::Felt, provider: P) -> Self {
        Self {
            address,
            provider,
            block_id: starknet::core::types::BlockId::Tag(
                starknet::core::types::BlockTag::Pending,
            ),
        }
    }
    pub fn set_contract_address(&mut self, address: starknet::core::types::Felt) {
        self.address = address;
    }
    pub fn provider(&self) -> &P {
        &self.provider
    }
    pub fn set_block(&mut self, block_id: starknet::core::types::BlockId) {
        self.block_id = block_id;
    }
    pub fn with_block(self, block_id: starknet::core::types::BlockId) -> Self {
        Self { block_id, ..self }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub struct CampaignMembers {
    pub user_address: cainome::cairo_serde::ContractAddress,
    pub protocol_id: cainome::cairo_serde::U256,
    pub campaign_details: Option<ProtocolDetails>,
    pub protocol_token_id: cainome::cairo_serde::U256,
}
impl cainome::cairo_serde::CairoSerde for CampaignMembers {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.user_address,
            );
        __size += cainome::cairo_serde::U256::cairo_serialized_size(&__rust.protocol_id);
        __size
            += Option::<
                ProtocolDetails,
            >::cairo_serialized_size(&__rust.campaign_details);
        __size
            += cainome::cairo_serde::U256::cairo_serialized_size(
                &__rust.protocol_token_id,
            );
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        let mut __out: Vec<starknet::core::types::Felt> = vec![];
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(
                    &__rust.user_address,
                ),
            );
        __out.extend(cainome::cairo_serde::U256::cairo_serialize(&__rust.protocol_id));
        __out
            .extend(
                Option::<ProtocolDetails>::cairo_serialize(&__rust.campaign_details),
            );
        __out
            .extend(
                cainome::cairo_serde::U256::cairo_serialize(&__rust.protocol_token_id),
            );
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let user_address = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &user_address,
            );
        let protocol_id = cainome::cairo_serde::U256::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset += cainome::cairo_serde::U256::cairo_serialized_size(&protocol_id);
        let campaign_details = Option::<
            ProtocolDetails,
        >::cairo_deserialize(__felts, __offset)?;
        __offset += Option::<ProtocolDetails>::cairo_serialized_size(&campaign_details);
        let protocol_token_id = cainome::cairo_serde::U256::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::U256::cairo_serialized_size(&protocol_token_id);
        Ok(CampaignMembers {
            user_address,
            protocol_id,
            campaign_details,
            protocol_token_id,
        })
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub struct DeployProtocolNft {
    pub protocol_id: cainome::cairo_serde::U256,
    pub protocol_nft: cainome::cairo_serde::ContractAddress,
    pub block_timestamp: u64,
}
impl cainome::cairo_serde::CairoSerde for DeployProtocolNft {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size += cainome::cairo_serde::U256::cairo_serialized_size(&__rust.protocol_id);
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.protocol_nft,
            );
        __size += u64::cairo_serialized_size(&__rust.block_timestamp);
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        let mut __out: Vec<starknet::core::types::Felt> = vec![];
        __out.extend(cainome::cairo_serde::U256::cairo_serialize(&__rust.protocol_id));
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(
                    &__rust.protocol_nft,
                ),
            );
        __out.extend(u64::cairo_serialize(&__rust.block_timestamp));
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let protocol_id = cainome::cairo_serde::U256::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset += cainome::cairo_serde::U256::cairo_serialized_size(&protocol_id);
        let protocol_nft = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &protocol_nft,
            );
        let block_timestamp = u64::cairo_deserialize(__felts, __offset)?;
        __offset += u64::cairo_serialized_size(&block_timestamp);
        Ok(DeployProtocolNft {
            protocol_id,
            protocol_nft,
            block_timestamp,
        })
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub struct JoinProtocolCampaign {
    pub protocol_id: cainome::cairo_serde::U256,
    pub caller: cainome::cairo_serde::ContractAddress,
    pub token_id: cainome::cairo_serde::U256,
    pub user: cainome::cairo_serde::ContractAddress,
    pub block_timestamp: u64,
}
impl cainome::cairo_serde::CairoSerde for JoinProtocolCampaign {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size += cainome::cairo_serde::U256::cairo_serialized_size(&__rust.protocol_id);
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.caller,
            );
        __size += cainome::cairo_serde::U256::cairo_serialized_size(&__rust.token_id);
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.user,
            );
        __size += u64::cairo_serialized_size(&__rust.block_timestamp);
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        let mut __out: Vec<starknet::core::types::Felt> = vec![];
        __out.extend(cainome::cairo_serde::U256::cairo_serialize(&__rust.protocol_id));
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(&__rust.caller),
            );
        __out.extend(cainome::cairo_serde::U256::cairo_serialize(&__rust.token_id));
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(&__rust.user),
            );
        __out.extend(u64::cairo_serialize(&__rust.block_timestamp));
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let protocol_id = cainome::cairo_serde::U256::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset += cainome::cairo_serde::U256::cairo_serialized_size(&protocol_id);
        let caller = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&caller);
        let token_id = cainome::cairo_serde::U256::cairo_deserialize(__felts, __offset)?;
        __offset += cainome::cairo_serde::U256::cairo_serialized_size(&token_id);
        let user = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&user);
        let block_timestamp = u64::cairo_deserialize(__felts, __offset)?;
        __offset += u64::cairo_serialized_size(&block_timestamp);
        Ok(JoinProtocolCampaign {
            protocol_id,
            caller,
            token_id,
            user,
            block_timestamp,
        })
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub struct OwnershipTransferStarted {
    pub previous_owner: cainome::cairo_serde::ContractAddress,
    pub new_owner: cainome::cairo_serde::ContractAddress,
}
impl cainome::cairo_serde::CairoSerde for OwnershipTransferStarted {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.previous_owner,
            );
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.new_owner,
            );
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        let mut __out: Vec<starknet::core::types::Felt> = vec![];
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(
                    &__rust.previous_owner,
                ),
            );
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(&__rust.new_owner),
            );
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let previous_owner = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &previous_owner,
            );
        let new_owner = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&new_owner);
        Ok(OwnershipTransferStarted {
            previous_owner,
            new_owner,
        })
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub struct OwnershipTransferred {
    pub previous_owner: cainome::cairo_serde::ContractAddress,
    pub new_owner: cainome::cairo_serde::ContractAddress,
}
impl cainome::cairo_serde::CairoSerde for OwnershipTransferred {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.previous_owner,
            );
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.new_owner,
            );
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        let mut __out: Vec<starknet::core::types::Felt> = vec![];
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(
                    &__rust.previous_owner,
                ),
            );
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(&__rust.new_owner),
            );
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let previous_owner = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &previous_owner,
            );
        let new_owner = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&new_owner);
        Ok(OwnershipTransferred {
            previous_owner,
            new_owner,
        })
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub struct ProtocolCampaign {
    pub protocol_id: cainome::cairo_serde::U256,
    pub protocol_owner: cainome::cairo_serde::ContractAddress,
    pub protocol_nft_address: cainome::cairo_serde::ContractAddress,
    pub block_timestamp: u64,
}
impl cainome::cairo_serde::CairoSerde for ProtocolCampaign {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size += cainome::cairo_serde::U256::cairo_serialized_size(&__rust.protocol_id);
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.protocol_owner,
            );
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.protocol_nft_address,
            );
        __size += u64::cairo_serialized_size(&__rust.block_timestamp);
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        let mut __out: Vec<starknet::core::types::Felt> = vec![];
        __out.extend(cainome::cairo_serde::U256::cairo_serialize(&__rust.protocol_id));
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(
                    &__rust.protocol_owner,
                ),
            );
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(
                    &__rust.protocol_nft_address,
                ),
            );
        __out.extend(u64::cairo_serialize(&__rust.block_timestamp));
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let protocol_id = cainome::cairo_serde::U256::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset += cainome::cairo_serde::U256::cairo_serialized_size(&protocol_id);
        let protocol_owner = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &protocol_owner,
            );
        let protocol_nft_address = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &protocol_nft_address,
            );
        let block_timestamp = u64::cairo_deserialize(__felts, __offset)?;
        __offset += u64::cairo_serialized_size(&block_timestamp);
        Ok(ProtocolCampaign {
            protocol_id,
            protocol_owner,
            protocol_nft_address,
            block_timestamp,
        })
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub struct ProtocolDetails {
    pub protocol_id: cainome::cairo_serde::U256,
    pub protocol_owner: cainome::cairo_serde::ContractAddress,
    pub protocol_matadata_uri: cainome::cairo_serde::ByteArray,
    pub protocol_nft_address: cainome::cairo_serde::ContractAddress,
    pub protocol_details: Option<ProtocolInfo>,
    pub protocol_campaign_members: cainome::cairo_serde::U256,
    pub protocol_info: cainome::cairo_serde::ByteArray,
}
impl cainome::cairo_serde::CairoSerde for ProtocolDetails {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size += cainome::cairo_serde::U256::cairo_serialized_size(&__rust.protocol_id);
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.protocol_owner,
            );
        __size
            += cainome::cairo_serde::ByteArray::cairo_serialized_size(
                &__rust.protocol_matadata_uri,
            );
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.protocol_nft_address,
            );
        __size
            += Option::<ProtocolInfo>::cairo_serialized_size(&__rust.protocol_details);
        __size
            += cainome::cairo_serde::U256::cairo_serialized_size(
                &__rust.protocol_campaign_members,
            );
        __size
            += cainome::cairo_serde::ByteArray::cairo_serialized_size(
                &__rust.protocol_info,
            );
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        let mut __out: Vec<starknet::core::types::Felt> = vec![];
        __out.extend(cainome::cairo_serde::U256::cairo_serialize(&__rust.protocol_id));
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(
                    &__rust.protocol_owner,
                ),
            );
        __out
            .extend(
                cainome::cairo_serde::ByteArray::cairo_serialize(
                    &__rust.protocol_matadata_uri,
                ),
            );
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(
                    &__rust.protocol_nft_address,
                ),
            );
        __out.extend(Option::<ProtocolInfo>::cairo_serialize(&__rust.protocol_details));
        __out
            .extend(
                cainome::cairo_serde::U256::cairo_serialize(
                    &__rust.protocol_campaign_members,
                ),
            );
        __out
            .extend(
                cainome::cairo_serde::ByteArray::cairo_serialize(&__rust.protocol_info),
            );
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let protocol_id = cainome::cairo_serde::U256::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset += cainome::cairo_serde::U256::cairo_serialized_size(&protocol_id);
        let protocol_owner = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &protocol_owner,
            );
        let protocol_matadata_uri = cainome::cairo_serde::ByteArray::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ByteArray::cairo_serialized_size(
                &protocol_matadata_uri,
            );
        let protocol_nft_address = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &protocol_nft_address,
            );
        let protocol_details = Option::<
            ProtocolInfo,
        >::cairo_deserialize(__felts, __offset)?;
        __offset += Option::<ProtocolInfo>::cairo_serialized_size(&protocol_details);
        let protocol_campaign_members = cainome::cairo_serde::U256::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::U256::cairo_serialized_size(
                &protocol_campaign_members,
            );
        let protocol_info = cainome::cairo_serde::ByteArray::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ByteArray::cairo_serialized_size(&protocol_info);
        Ok(ProtocolDetails {
            protocol_id,
            protocol_owner,
            protocol_matadata_uri,
            protocol_nft_address,
            protocol_details,
            protocol_campaign_members,
            protocol_info,
        })
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub struct ProtocolInfo {
    pub protocol_Details: cainome::cairo_serde::ByteArray,
    pub registered: bool,
    pub verified: bool,
    pub protocol_id: cainome::cairo_serde::U256,
    pub protocol_owner: cainome::cairo_serde::ContractAddress,
}
impl cainome::cairo_serde::CairoSerde for ProtocolInfo {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size
            += cainome::cairo_serde::ByteArray::cairo_serialized_size(
                &__rust.protocol_Details,
            );
        __size += bool::cairo_serialized_size(&__rust.registered);
        __size += bool::cairo_serialized_size(&__rust.verified);
        __size += cainome::cairo_serde::U256::cairo_serialized_size(&__rust.protocol_id);
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.protocol_owner,
            );
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        let mut __out: Vec<starknet::core::types::Felt> = vec![];
        __out
            .extend(
                cainome::cairo_serde::ByteArray::cairo_serialize(
                    &__rust.protocol_Details,
                ),
            );
        __out.extend(bool::cairo_serialize(&__rust.registered));
        __out.extend(bool::cairo_serialize(&__rust.verified));
        __out.extend(cainome::cairo_serde::U256::cairo_serialize(&__rust.protocol_id));
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(
                    &__rust.protocol_owner,
                ),
            );
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let protocol_Details = cainome::cairo_serde::ByteArray::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ByteArray::cairo_serialized_size(&protocol_Details);
        let registered = bool::cairo_deserialize(__felts, __offset)?;
        __offset += bool::cairo_serialized_size(&registered);
        let verified = bool::cairo_deserialize(__felts, __offset)?;
        __offset += bool::cairo_serialized_size(&verified);
        let protocol_id = cainome::cairo_serde::U256::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset += cainome::cairo_serde::U256::cairo_serialized_size(&protocol_id);
        let protocol_owner = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &protocol_owner,
            );
        Ok(ProtocolInfo {
            protocol_Details,
            registered,
            verified,
            protocol_id,
            protocol_owner,
        })
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub struct ProtocolRegistered {
    pub protocol_id: cainome::cairo_serde::U256,
    pub protocol_owner: cainome::cairo_serde::ContractAddress,
    pub event_type: UserEventType,
    pub block_timestamp: u64,
}
impl cainome::cairo_serde::CairoSerde for ProtocolRegistered {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        let mut __size = 0;
        __size += cainome::cairo_serde::U256::cairo_serialized_size(&__rust.protocol_id);
        __size
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &__rust.protocol_owner,
            );
        __size += UserEventType::cairo_serialized_size(&__rust.event_type);
        __size += u64::cairo_serialized_size(&__rust.block_timestamp);
        __size
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        let mut __out: Vec<starknet::core::types::Felt> = vec![];
        __out.extend(cainome::cairo_serde::U256::cairo_serialize(&__rust.protocol_id));
        __out
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(
                    &__rust.protocol_owner,
                ),
            );
        __out.extend(UserEventType::cairo_serialize(&__rust.event_type));
        __out.extend(u64::cairo_serialize(&__rust.block_timestamp));
        __out
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let mut __offset = __offset;
        let protocol_id = cainome::cairo_serde::U256::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset += cainome::cairo_serde::U256::cairo_serialized_size(&protocol_id);
        let protocol_owner = cainome::cairo_serde::ContractAddress::cairo_deserialize(
            __felts,
            __offset,
        )?;
        __offset
            += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                &protocol_owner,
            );
        let event_type = UserEventType::cairo_deserialize(__felts, __offset)?;
        __offset += UserEventType::cairo_serialized_size(&event_type);
        let block_timestamp = u64::cairo_deserialize(__felts, __offset)?;
        __offset += u64::cairo_serialized_size(&block_timestamp);
        Ok(ProtocolRegistered {
            protocol_id,
            protocol_owner,
            event_type,
            block_timestamp,
        })
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub enum Event {
    ProtocolEvent(ProtocolCampaignEvent),
    OwnableEvent(OwnableComponentEvent),
}
impl cainome::cairo_serde::CairoSerde for Event {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = std::option::Option::None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        match __rust {
            Event::ProtocolEvent(val) => {
                ProtocolCampaignEvent::cairo_serialized_size(val) + 1
            }
            Event::OwnableEvent(val) => {
                OwnableComponentEvent::cairo_serialized_size(val) + 1
            }
            _ => 0,
        }
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        match __rust {
            Event::ProtocolEvent(val) => {
                let mut temp = vec![];
                temp.extend(usize::cairo_serialize(&0usize));
                temp.extend(ProtocolCampaignEvent::cairo_serialize(val));
                temp
            }
            Event::OwnableEvent(val) => {
                let mut temp = vec![];
                temp.extend(usize::cairo_serialize(&1usize));
                temp.extend(OwnableComponentEvent::cairo_serialize(val));
                temp
            }
            _ => vec![],
        }
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let __f = __felts[__offset];
        let __index = u128::from_be_bytes(__f.to_bytes_be()[16..].try_into().unwrap());
        match __index as usize {
            0usize => {
                Ok(
                    Event::ProtocolEvent(
                        ProtocolCampaignEvent::cairo_deserialize(__felts, __offset + 1)?,
                    ),
                )
            }
            1usize => {
                Ok(
                    Event::OwnableEvent(
                        OwnableComponentEvent::cairo_deserialize(__felts, __offset + 1)?,
                    ),
                )
            }
            _ => {
                return Err(
                    cainome::cairo_serde::Error::Deserialize(
                        format!("Index not handle for enum {}", "Event"),
                    ),
                );
            }
        }
    }
}
impl TryFrom<starknet::core::types::EmittedEvent> for Event {
    type Error = String;
    fn try_from(
        event: starknet::core::types::EmittedEvent,
    ) -> Result<Self, Self::Error> {
        use cainome::cairo_serde::CairoSerde;
        if event.keys.is_empty() {
            return Err("Event has no key".to_string());
        }
        let selector = event.keys[0];
        if selector
            == starknet::core::utils::get_selector_from_name("ProtocolCampaign")
                .unwrap_or_else(|_| {
                    panic!("Invalid selector for {}", "ProtocolCampaign")
                })
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let protocol_id = match cainome::cairo_serde::U256::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "protocol_id",
                            "ProtocolCampaign", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::U256::cairo_serialized_size(&protocol_id);
            let protocol_owner = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "protocol_owner", "ProtocolCampaign", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &protocol_owner,
                );
            let protocol_nft_address = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "protocol_nft_address", "ProtocolCampaign", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &protocol_nft_address,
                );
            let block_timestamp = match u64::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "block_timestamp", "ProtocolCampaign", e
                        ),
                    );
                }
            };
            data_offset += u64::cairo_serialized_size(&block_timestamp);
            return Ok(
                Event::ProtocolEvent(
                    ProtocolCampaignEvent::ProtocolCampaign(ProtocolCampaign {
                        protocol_id,
                        protocol_owner,
                        protocol_nft_address,
                        block_timestamp,
                    }),
                ),
            );
        }
        let selector = event.keys[0];
        if selector
            == starknet::core::utils::get_selector_from_name("JoinProtocolCampaign")
                .unwrap_or_else(|_| {
                    panic!("Invalid selector for {}", "JoinProtocolCampaign")
                })
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let protocol_id = match cainome::cairo_serde::U256::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "protocol_id",
                            "JoinProtocolCampaign", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::U256::cairo_serialized_size(&protocol_id);
            let caller = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "caller",
                            "JoinProtocolCampaign", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&caller);
            let token_id = match cainome::cairo_serde::U256::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "token_id",
                            "JoinProtocolCampaign", e
                        ),
                    );
                }
            };
            data_offset += cainome::cairo_serde::U256::cairo_serialized_size(&token_id);
            let user = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "user",
                            "JoinProtocolCampaign", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&user);
            let block_timestamp = match u64::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "block_timestamp", "JoinProtocolCampaign", e
                        ),
                    );
                }
            };
            data_offset += u64::cairo_serialized_size(&block_timestamp);
            return Ok(
                Event::ProtocolEvent(
                    ProtocolCampaignEvent::JoinProtocolCampaign(JoinProtocolCampaign {
                        protocol_id,
                        caller,
                        token_id,
                        user,
                        block_timestamp,
                    }),
                ),
            );
        }
        let selector = event.keys[0];
        if selector
            == starknet::core::utils::get_selector_from_name("DeployProtocolNft")
                .unwrap_or_else(|_| {
                    panic!("Invalid selector for {}", "DeployProtocolNft")
                })
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let protocol_id = match cainome::cairo_serde::U256::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "protocol_id",
                            "DeployProtocolNft", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::U256::cairo_serialized_size(&protocol_id);
            let protocol_nft = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "protocol_nft", "DeployProtocolNft", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &protocol_nft,
                );
            let block_timestamp = match u64::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "block_timestamp", "DeployProtocolNft", e
                        ),
                    );
                }
            };
            data_offset += u64::cairo_serialized_size(&block_timestamp);
            return Ok(
                Event::ProtocolEvent(
                    ProtocolCampaignEvent::DeployProtocolNft(DeployProtocolNft {
                        protocol_id,
                        protocol_nft,
                        block_timestamp,
                    }),
                ),
            );
        }
        let selector = event.keys[0];
        if selector
            == starknet::core::utils::get_selector_from_name("ProtocolRegistered")
                .unwrap_or_else(|_| {
                    panic!("Invalid selector for {}", "ProtocolRegistered")
                })
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let protocol_id = match cainome::cairo_serde::U256::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "protocol_id",
                            "ProtocolRegistered", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::U256::cairo_serialized_size(&protocol_id);
            let protocol_owner = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "protocol_owner", "ProtocolRegistered", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &protocol_owner,
                );
            let event_type = match UserEventType::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "event_type",
                            "ProtocolRegistered", e
                        ),
                    );
                }
            };
            data_offset += UserEventType::cairo_serialized_size(&event_type);
            let block_timestamp = match u64::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "block_timestamp", "ProtocolRegistered", e
                        ),
                    );
                }
            };
            data_offset += u64::cairo_serialized_size(&block_timestamp);
            return Ok(
                Event::ProtocolEvent(
                    ProtocolCampaignEvent::ProtocolRegistered(ProtocolRegistered {
                        protocol_id,
                        protocol_owner,
                        event_type,
                        block_timestamp,
                    }),
                ),
            );
        }
        let selector = event.keys[0];
        if selector
            == starknet::core::utils::get_selector_from_name("OwnershipTransferred")
                .unwrap_or_else(|_| {
                    panic!("Invalid selector for {}", "OwnershipTransferred")
                })
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let previous_owner = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.keys,
                key_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "previous_owner", "OwnershipTransferred", e
                        ),
                    );
                }
            };
            key_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &previous_owner,
                );
            let new_owner = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.keys,
                key_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "new_owner",
                            "OwnershipTransferred", e
                        ),
                    );
                }
            };
            key_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &new_owner,
                );
            return Ok(
                Event::OwnableEvent(
                    OwnableComponentEvent::OwnershipTransferred(OwnershipTransferred {
                        previous_owner,
                        new_owner,
                    }),
                ),
            );
        }
        let selector = event.keys[0];
        if selector
            == starknet::core::utils::get_selector_from_name("OwnershipTransferStarted")
                .unwrap_or_else(|_| {
                    panic!("Invalid selector for {}", "OwnershipTransferStarted")
                })
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let previous_owner = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.keys,
                key_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "previous_owner", "OwnershipTransferStarted", e
                        ),
                    );
                }
            };
            key_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &previous_owner,
                );
            let new_owner = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.keys,
                key_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "new_owner",
                            "OwnershipTransferStarted", e
                        ),
                    );
                }
            };
            key_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &new_owner,
                );
            return Ok(
                Event::OwnableEvent(
                    OwnableComponentEvent::OwnershipTransferStarted(OwnershipTransferStarted {
                        previous_owner,
                        new_owner,
                    }),
                ),
            );
        }
        Err(format!("Could not match any event from keys {:?}", event.keys))
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub enum OwnableComponentEvent {
    OwnershipTransferred(OwnershipTransferred),
    OwnershipTransferStarted(OwnershipTransferStarted),
}
impl cainome::cairo_serde::CairoSerde for OwnableComponentEvent {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = std::option::Option::None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        match __rust {
            OwnableComponentEvent::OwnershipTransferred(val) => {
                OwnershipTransferred::cairo_serialized_size(val) + 1
            }
            OwnableComponentEvent::OwnershipTransferStarted(val) => {
                OwnershipTransferStarted::cairo_serialized_size(val) + 1
            }
            _ => 0,
        }
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        match __rust {
            OwnableComponentEvent::OwnershipTransferred(val) => {
                let mut temp = vec![];
                temp.extend(usize::cairo_serialize(&0usize));
                temp.extend(OwnershipTransferred::cairo_serialize(val));
                temp
            }
            OwnableComponentEvent::OwnershipTransferStarted(val) => {
                let mut temp = vec![];
                temp.extend(usize::cairo_serialize(&1usize));
                temp.extend(OwnershipTransferStarted::cairo_serialize(val));
                temp
            }
            _ => vec![],
        }
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let __f = __felts[__offset];
        let __index = u128::from_be_bytes(__f.to_bytes_be()[16..].try_into().unwrap());
        match __index as usize {
            0usize => {
                Ok(
                    OwnableComponentEvent::OwnershipTransferred(
                        OwnershipTransferred::cairo_deserialize(__felts, __offset + 1)?,
                    ),
                )
            }
            1usize => {
                Ok(
                    OwnableComponentEvent::OwnershipTransferStarted(
                        OwnershipTransferStarted::cairo_deserialize(
                            __felts,
                            __offset + 1,
                        )?,
                    ),
                )
            }
            _ => {
                return Err(
                    cainome::cairo_serde::Error::Deserialize(
                        format!("Index not handle for enum {}", "OwnableComponentEvent"),
                    ),
                );
            }
        }
    }
}
impl TryFrom<starknet::core::types::EmittedEvent> for OwnableComponentEvent {
    type Error = String;
    fn try_from(
        event: starknet::core::types::EmittedEvent,
    ) -> Result<Self, Self::Error> {
        use cainome::cairo_serde::CairoSerde;
        if event.keys.is_empty() {
            return Err("Event has no key".to_string());
        }
        let selector = event.keys[0];
        if selector
            == starknet::core::utils::get_selector_from_name("OwnershipTransferred")
                .unwrap_or_else(|_| {
                    panic!("Invalid selector for {}", "OwnershipTransferred")
                })
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let previous_owner = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.keys,
                key_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "previous_owner", "OwnershipTransferred", e
                        ),
                    );
                }
            };
            key_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &previous_owner,
                );
            let new_owner = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.keys,
                key_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "new_owner",
                            "OwnershipTransferred", e
                        ),
                    );
                }
            };
            key_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &new_owner,
                );
            return Ok(
                OwnableComponentEvent::OwnershipTransferred(OwnershipTransferred {
                    previous_owner,
                    new_owner,
                }),
            );
        }
        let selector = event.keys[0];
        if selector
            == starknet::core::utils::get_selector_from_name("OwnershipTransferStarted")
                .unwrap_or_else(|_| {
                    panic!("Invalid selector for {}", "OwnershipTransferStarted")
                })
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let previous_owner = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.keys,
                key_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "previous_owner", "OwnershipTransferStarted", e
                        ),
                    );
                }
            };
            key_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &previous_owner,
                );
            let new_owner = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.keys,
                key_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "new_owner",
                            "OwnershipTransferStarted", e
                        ),
                    );
                }
            };
            key_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &new_owner,
                );
            return Ok(
                OwnableComponentEvent::OwnershipTransferStarted(OwnershipTransferStarted {
                    previous_owner,
                    new_owner,
                }),
            );
        }
        Err(format!("Could not match any event from keys {:?}", event.keys))
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub enum ProtocolCampaignEvent {
    ProtocolCampaign(ProtocolCampaign),
    JoinProtocolCampaign(JoinProtocolCampaign),
    DeployProtocolNft(DeployProtocolNft),
    ProtocolRegistered(ProtocolRegistered),
}
impl cainome::cairo_serde::CairoSerde for ProtocolCampaignEvent {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = std::option::Option::None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        match __rust {
            ProtocolCampaignEvent::ProtocolCampaign(val) => {
                ProtocolCampaign::cairo_serialized_size(val) + 1
            }
            ProtocolCampaignEvent::JoinProtocolCampaign(val) => {
                JoinProtocolCampaign::cairo_serialized_size(val) + 1
            }
            ProtocolCampaignEvent::DeployProtocolNft(val) => {
                DeployProtocolNft::cairo_serialized_size(val) + 1
            }
            ProtocolCampaignEvent::ProtocolRegistered(val) => {
                ProtocolRegistered::cairo_serialized_size(val) + 1
            }
            _ => 0,
        }
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        match __rust {
            ProtocolCampaignEvent::ProtocolCampaign(val) => {
                let mut temp = vec![];
                temp.extend(usize::cairo_serialize(&0usize));
                temp.extend(ProtocolCampaign::cairo_serialize(val));
                temp
            }
            ProtocolCampaignEvent::JoinProtocolCampaign(val) => {
                let mut temp = vec![];
                temp.extend(usize::cairo_serialize(&1usize));
                temp.extend(JoinProtocolCampaign::cairo_serialize(val));
                temp
            }
            ProtocolCampaignEvent::DeployProtocolNft(val) => {
                let mut temp = vec![];
                temp.extend(usize::cairo_serialize(&2usize));
                temp.extend(DeployProtocolNft::cairo_serialize(val));
                temp
            }
            ProtocolCampaignEvent::ProtocolRegistered(val) => {
                let mut temp = vec![];
                temp.extend(usize::cairo_serialize(&3usize));
                temp.extend(ProtocolRegistered::cairo_serialize(val));
                temp
            }
            _ => vec![],
        }
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let __f = __felts[__offset];
        let __index = u128::from_be_bytes(__f.to_bytes_be()[16..].try_into().unwrap());
        match __index as usize {
            0usize => {
                Ok(
                    ProtocolCampaignEvent::ProtocolCampaign(
                        ProtocolCampaign::cairo_deserialize(__felts, __offset + 1)?,
                    ),
                )
            }
            1usize => {
                Ok(
                    ProtocolCampaignEvent::JoinProtocolCampaign(
                        JoinProtocolCampaign::cairo_deserialize(__felts, __offset + 1)?,
                    ),
                )
            }
            2usize => {
                Ok(
                    ProtocolCampaignEvent::DeployProtocolNft(
                        DeployProtocolNft::cairo_deserialize(__felts, __offset + 1)?,
                    ),
                )
            }
            3usize => {
                Ok(
                    ProtocolCampaignEvent::ProtocolRegistered(
                        ProtocolRegistered::cairo_deserialize(__felts, __offset + 1)?,
                    ),
                )
            }
            _ => {
                return Err(
                    cainome::cairo_serde::Error::Deserialize(
                        format!("Index not handle for enum {}", "ProtocolCampaignEvent"),
                    ),
                );
            }
        }
    }
}
impl TryFrom<starknet::core::types::EmittedEvent> for ProtocolCampaignEvent {
    type Error = String;
    fn try_from(
        event: starknet::core::types::EmittedEvent,
    ) -> Result<Self, Self::Error> {
        use cainome::cairo_serde::CairoSerde;
        if event.keys.is_empty() {
            return Err("Event has no key".to_string());
        }
        let selector = event.keys[0];
        if selector
            == starknet::core::utils::get_selector_from_name("ProtocolCampaign")
                .unwrap_or_else(|_| {
                    panic!("Invalid selector for {}", "ProtocolCampaign")
                })
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let protocol_id = match cainome::cairo_serde::U256::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "protocol_id",
                            "ProtocolCampaign", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::U256::cairo_serialized_size(&protocol_id);
            let protocol_owner = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "protocol_owner", "ProtocolCampaign", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &protocol_owner,
                );
            let protocol_nft_address = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "protocol_nft_address", "ProtocolCampaign", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &protocol_nft_address,
                );
            let block_timestamp = match u64::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "block_timestamp", "ProtocolCampaign", e
                        ),
                    );
                }
            };
            data_offset += u64::cairo_serialized_size(&block_timestamp);
            return Ok(
                ProtocolCampaignEvent::ProtocolCampaign(ProtocolCampaign {
                    protocol_id,
                    protocol_owner,
                    protocol_nft_address,
                    block_timestamp,
                }),
            );
        }
        let selector = event.keys[0];
        if selector
            == starknet::core::utils::get_selector_from_name("JoinProtocolCampaign")
                .unwrap_or_else(|_| {
                    panic!("Invalid selector for {}", "JoinProtocolCampaign")
                })
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let protocol_id = match cainome::cairo_serde::U256::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "protocol_id",
                            "JoinProtocolCampaign", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::U256::cairo_serialized_size(&protocol_id);
            let caller = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "caller",
                            "JoinProtocolCampaign", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&caller);
            let token_id = match cainome::cairo_serde::U256::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "token_id",
                            "JoinProtocolCampaign", e
                        ),
                    );
                }
            };
            data_offset += cainome::cairo_serde::U256::cairo_serialized_size(&token_id);
            let user = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "user",
                            "JoinProtocolCampaign", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(&user);
            let block_timestamp = match u64::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "block_timestamp", "JoinProtocolCampaign", e
                        ),
                    );
                }
            };
            data_offset += u64::cairo_serialized_size(&block_timestamp);
            return Ok(
                ProtocolCampaignEvent::JoinProtocolCampaign(JoinProtocolCampaign {
                    protocol_id,
                    caller,
                    token_id,
                    user,
                    block_timestamp,
                }),
            );
        }
        let selector = event.keys[0];
        if selector
            == starknet::core::utils::get_selector_from_name("DeployProtocolNft")
                .unwrap_or_else(|_| {
                    panic!("Invalid selector for {}", "DeployProtocolNft")
                })
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let protocol_id = match cainome::cairo_serde::U256::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "protocol_id",
                            "DeployProtocolNft", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::U256::cairo_serialized_size(&protocol_id);
            let protocol_nft = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "protocol_nft", "DeployProtocolNft", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &protocol_nft,
                );
            let block_timestamp = match u64::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "block_timestamp", "DeployProtocolNft", e
                        ),
                    );
                }
            };
            data_offset += u64::cairo_serialized_size(&block_timestamp);
            return Ok(
                ProtocolCampaignEvent::DeployProtocolNft(DeployProtocolNft {
                    protocol_id,
                    protocol_nft,
                    block_timestamp,
                }),
            );
        }
        let selector = event.keys[0];
        if selector
            == starknet::core::utils::get_selector_from_name("ProtocolRegistered")
                .unwrap_or_else(|_| {
                    panic!("Invalid selector for {}", "ProtocolRegistered")
                })
        {
            let mut key_offset = 0 + 1;
            let mut data_offset = 0;
            let protocol_id = match cainome::cairo_serde::U256::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "protocol_id",
                            "ProtocolRegistered", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::U256::cairo_serialized_size(&protocol_id);
            let protocol_owner = match cainome::cairo_serde::ContractAddress::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "protocol_owner", "ProtocolRegistered", e
                        ),
                    );
                }
            };
            data_offset
                += cainome::cairo_serde::ContractAddress::cairo_serialized_size(
                    &protocol_owner,
                );
            let event_type = match UserEventType::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}", "event_type",
                            "ProtocolRegistered", e
                        ),
                    );
                }
            };
            data_offset += UserEventType::cairo_serialized_size(&event_type);
            let block_timestamp = match u64::cairo_deserialize(
                &event.data,
                data_offset,
            ) {
                Ok(v) => v,
                Err(e) => {
                    return Err(
                        format!(
                            "Could not deserialize field {} for {}: {:?}",
                            "block_timestamp", "ProtocolRegistered", e
                        ),
                    );
                }
            };
            data_offset += u64::cairo_serialized_size(&block_timestamp);
            return Ok(
                ProtocolCampaignEvent::ProtocolRegistered(ProtocolRegistered {
                    protocol_id,
                    protocol_owner,
                    event_type,
                    block_timestamp,
                }),
            );
        }
        Err(format!("Could not match any event from keys {:?}", event.keys))
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
pub enum UserEventType {
    Register,
    Verify,
}
impl cainome::cairo_serde::CairoSerde for UserEventType {
    type RustType = Self;
    const SERIALIZED_SIZE: std::option::Option<usize> = std::option::Option::None;
    #[inline]
    fn cairo_serialized_size(__rust: &Self::RustType) -> usize {
        match __rust {
            UserEventType::Register => 1,
            UserEventType::Verify => 1,
            _ => 0,
        }
    }
    fn cairo_serialize(__rust: &Self::RustType) -> Vec<starknet::core::types::Felt> {
        match __rust {
            UserEventType::Register => usize::cairo_serialize(&0usize),
            UserEventType::Verify => usize::cairo_serialize(&1usize),
            _ => vec![],
        }
    }
    fn cairo_deserialize(
        __felts: &[starknet::core::types::Felt],
        __offset: usize,
    ) -> cainome::cairo_serde::Result<Self::RustType> {
        let __f = __felts[__offset];
        let __index = u128::from_be_bytes(__f.to_bytes_be()[16..].try_into().unwrap());
        match __index as usize {
            0usize => Ok(UserEventType::Register),
            1usize => Ok(UserEventType::Verify),
            _ => {
                return Err(
                    cainome::cairo_serde::Error::Deserialize(
                        format!("Index not handle for enum {}", "UserEventType"),
                    ),
                );
            }
        }
    }
}
impl<A: starknet::accounts::ConnectedAccount + Sync> protocols<A> {
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_all_campaign_for_members(
        &self,
        user: &cainome::cairo_serde::ContractAddress,
    ) -> cainome::cairo_serde::call::FCall<A::Provider, Vec<CampaignMembers>> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(user));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!(
                "get_all_campaign_for_members"
            ),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_all_protocol_details(
        &self,
    ) -> cainome::cairo_serde::call::FCall<A::Provider, Vec<ProtocolDetails>> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!(
                "get_all_protocol_details"
            ),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_campaign_for_member(
        &self,
        protocol_id: &cainome::cairo_serde::U256,
        user: &cainome::cairo_serde::ContractAddress,
    ) -> cainome::cairo_serde::call::FCall<A::Provider, CampaignMembers> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(protocol_id));
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(user));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("get_campaign_for_member"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_protocol(
        &self,
        protocol_id: &cainome::cairo_serde::U256,
    ) -> cainome::cairo_serde::call::FCall<A::Provider, ProtocolDetails> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(protocol_id));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("get_protocol"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_protocol_campaign_users(
        &self,
        protocol_id: &cainome::cairo_serde::U256,
    ) -> cainome::cairo_serde::call::FCall<A::Provider, cainome::cairo_serde::U256> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(protocol_id));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!(
                "get_protocol_campaign_users"
            ),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_protocol_matadata_uri(
        &self,
        protocol_id: &cainome::cairo_serde::U256,
    ) -> cainome::cairo_serde::call::FCall<
        A::Provider,
        cainome::cairo_serde::ByteArray,
    > {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(protocol_id));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!(
                "get_protocol_matadata_uri"
            ),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_protocol_nft_class_hash(
        &self,
    ) -> cainome::cairo_serde::call::FCall<
        A::Provider,
        cainome::cairo_serde::ClassHash,
    > {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!(
                "get_protocol_nft_class_hash"
            ),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_registered_protocol(
        &self,
        protocol_owner: &cainome::cairo_serde::ContractAddress,
    ) -> cainome::cairo_serde::call::FCall<A::Provider, ProtocolInfo> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(protocol_owner),
            );
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("get_registered_protocol"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn is_campaign_member(
        &self,
        campaign_user: &cainome::cairo_serde::ContractAddress,
        protocol_id: &cainome::cairo_serde::U256,
    ) -> cainome::cairo_serde::call::FCall<A::Provider, (bool, CampaignMembers)> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(campaign_user),
            );
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(protocol_id));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("is_campaign_member"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn create_protocol_campaign_getcall(
        &self,
        protocol_id: &cainome::cairo_serde::U256,
        protocol_info: &cainome::cairo_serde::ByteArray,
    ) -> starknet::core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(protocol_id));
        __calldata
            .extend(cainome::cairo_serde::ByteArray::cairo_serialize(protocol_info));
        starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("create_protocol_campaign"),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn create_protocol_campaign(
        &self,
        protocol_id: &cainome::cairo_serde::U256,
        protocol_info: &cainome::cairo_serde::ByteArray,
    ) -> starknet::accounts::ExecutionV1<A> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(protocol_id));
        __calldata
            .extend(cainome::cairo_serde::ByteArray::cairo_serialize(protocol_info));
        let __call = starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("create_protocol_campaign"),
            calldata: __calldata,
        };
        self.account.execute_v1(vec![__call])
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn join_protocol_campaign_getcall(
        &self,
        campaign_user: &cainome::cairo_serde::ContractAddress,
        protocol_id: &cainome::cairo_serde::U256,
    ) -> starknet::core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(campaign_user),
            );
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(protocol_id));
        starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("join_protocol_campaign"),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn join_protocol_campaign(
        &self,
        campaign_user: &cainome::cairo_serde::ContractAddress,
        protocol_id: &cainome::cairo_serde::U256,
    ) -> starknet::accounts::ExecutionV1<A> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(campaign_user),
            );
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(protocol_id));
        let __call = starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("join_protocol_campaign"),
            calldata: __calldata,
        };
        self.account.execute_v1(vec![__call])
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn protocol_register_getcall(
        &self,
        protocol_Details: &cainome::cairo_serde::ByteArray,
    ) -> starknet::core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(cainome::cairo_serde::ByteArray::cairo_serialize(protocol_Details));
        starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("protocol_register"),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn protocol_register(
        &self,
        protocol_Details: &cainome::cairo_serde::ByteArray,
    ) -> starknet::accounts::ExecutionV1<A> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(cainome::cairo_serde::ByteArray::cairo_serialize(protocol_Details));
        let __call = starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("protocol_register"),
            calldata: __calldata,
        };
        self.account.execute_v1(vec![__call])
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn set_protocol_matadata_uri_getcall(
        &self,
        protocol_id: &cainome::cairo_serde::U256,
        matadata_uri: &cainome::cairo_serde::ByteArray,
    ) -> starknet::core::types::Call {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(protocol_id));
        __calldata
            .extend(cainome::cairo_serde::ByteArray::cairo_serialize(matadata_uri));
        starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("set_protocol_matadata_uri"),
            calldata: __calldata,
        }
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn set_protocol_matadata_uri(
        &self,
        protocol_id: &cainome::cairo_serde::U256,
        matadata_uri: &cainome::cairo_serde::ByteArray,
    ) -> starknet::accounts::ExecutionV1<A> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(protocol_id));
        __calldata
            .extend(cainome::cairo_serde::ByteArray::cairo_serialize(matadata_uri));
        let __call = starknet::core::types::Call {
            to: self.address,
            selector: starknet::macros::selector!("set_protocol_matadata_uri"),
            calldata: __calldata,
        };
        self.account.execute_v1(vec![__call])
    }
}
impl<P: starknet::providers::Provider + Sync> protocolsReader<P> {
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_all_campaign_for_members(
        &self,
        user: &cainome::cairo_serde::ContractAddress,
    ) -> cainome::cairo_serde::call::FCall<P, Vec<CampaignMembers>> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(user));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!(
                "get_all_campaign_for_members"
            ),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_all_protocol_details(
        &self,
    ) -> cainome::cairo_serde::call::FCall<P, Vec<ProtocolDetails>> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!(
                "get_all_protocol_details"
            ),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_campaign_for_member(
        &self,
        protocol_id: &cainome::cairo_serde::U256,
        user: &cainome::cairo_serde::ContractAddress,
    ) -> cainome::cairo_serde::call::FCall<P, CampaignMembers> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(protocol_id));
        __calldata.extend(cainome::cairo_serde::ContractAddress::cairo_serialize(user));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("get_campaign_for_member"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_protocol(
        &self,
        protocol_id: &cainome::cairo_serde::U256,
    ) -> cainome::cairo_serde::call::FCall<P, ProtocolDetails> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(protocol_id));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("get_protocol"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_protocol_campaign_users(
        &self,
        protocol_id: &cainome::cairo_serde::U256,
    ) -> cainome::cairo_serde::call::FCall<P, cainome::cairo_serde::U256> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(protocol_id));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!(
                "get_protocol_campaign_users"
            ),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_protocol_matadata_uri(
        &self,
        protocol_id: &cainome::cairo_serde::U256,
    ) -> cainome::cairo_serde::call::FCall<P, cainome::cairo_serde::ByteArray> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(protocol_id));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!(
                "get_protocol_matadata_uri"
            ),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_protocol_nft_class_hash(
        &self,
    ) -> cainome::cairo_serde::call::FCall<P, cainome::cairo_serde::ClassHash> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!(
                "get_protocol_nft_class_hash"
            ),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn get_registered_protocol(
        &self,
        protocol_owner: &cainome::cairo_serde::ContractAddress,
    ) -> cainome::cairo_serde::call::FCall<P, ProtocolInfo> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(protocol_owner),
            );
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("get_registered_protocol"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
    #[allow(clippy::ptr_arg)]
    #[allow(clippy::too_many_arguments)]
    pub fn is_campaign_member(
        &self,
        campaign_user: &cainome::cairo_serde::ContractAddress,
        protocol_id: &cainome::cairo_serde::U256,
    ) -> cainome::cairo_serde::call::FCall<P, (bool, CampaignMembers)> {
        use cainome::cairo_serde::CairoSerde;
        let mut __calldata = vec![];
        __calldata
            .extend(
                cainome::cairo_serde::ContractAddress::cairo_serialize(campaign_user),
            );
        __calldata.extend(cainome::cairo_serde::U256::cairo_serialize(protocol_id));
        let __call = starknet::core::types::FunctionCall {
            contract_address: self.address,
            entry_point_selector: starknet::macros::selector!("is_campaign_member"),
            calldata: __calldata,
        };
        cainome::cairo_serde::call::FCall::new(__call, self.provider())
    }
}
